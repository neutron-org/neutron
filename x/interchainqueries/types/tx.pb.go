// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: neutron/interchainqueries/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	types1 "github.com/cometbft/cometbft/abci/types"
	crypto "github.com/cometbft/cometbft/proto/tendermint/crypto"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Request type for the Msg/RegisterInterchainQuery RPC method.
type MsgRegisterInterchainQuery struct {
	// The query type identifier: `kv` or `tx`.
	QueryType string `protobuf:"bytes,1,opt,name=query_type,json=queryType,proto3" json:"query_type,omitempty"`
	// The KV-storage keys for which we want to get values from remote chain. Only applicable for the
	// KV Interchain Queries. Max amount of keys is limited by the module's `max_kv_query_keys_count`
	// parameters.
	Keys []*KVKey `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	// A stringified list of filters for remote transactions search. Only applicable for the TX
	// Interchain Queries. Example: "[{\"field\":\"tx.height\",\"op\":\"Gte\",\"value\":2644737}]".
	// Supported operators: "eq", "lt", "gt", "lte", "gte". Max amount of filter conditions is
	// limited by the module's `max_transactions_filters` parameters.
	TransactionsFilter string `protobuf:"bytes,3,opt,name=transactions_filter,json=transactionsFilter,proto3" json:"transactions_filter,omitempty"`
	// The IBC connection ID to the remote chain (the source of querying data). Is used for getting
	// ConsensusState from the respective IBC client to verify query result proofs.
	ConnectionId string `protobuf:"bytes,4,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	// Parameter that defines the minimal delay between consecutive query executions (i.e. the
	// minimal delay between query results update).
	UpdatePeriod uint64 `protobuf:"varint,5,opt,name=update_period,json=updatePeriod,proto3" json:"update_period,omitempty"`
	// The signer of the message.
	Sender string `protobuf:"bytes,6,opt,name=sender,proto3" json:"sender,omitempty"`
}

func (m *MsgRegisterInterchainQuery) Reset()         { *m = MsgRegisterInterchainQuery{} }
func (m *MsgRegisterInterchainQuery) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterInterchainQuery) ProtoMessage()    {}
func (*MsgRegisterInterchainQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{0}
}
func (m *MsgRegisterInterchainQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterInterchainQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterInterchainQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterInterchainQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterInterchainQuery.Merge(m, src)
}
func (m *MsgRegisterInterchainQuery) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterInterchainQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterInterchainQuery.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterInterchainQuery proto.InternalMessageInfo

func (m *MsgRegisterInterchainQuery) GetQueryType() string {
	if m != nil {
		return m.QueryType
	}
	return ""
}

func (m *MsgRegisterInterchainQuery) GetKeys() []*KVKey {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *MsgRegisterInterchainQuery) GetTransactionsFilter() string {
	if m != nil {
		return m.TransactionsFilter
	}
	return ""
}

func (m *MsgRegisterInterchainQuery) GetConnectionId() string {
	if m != nil {
		return m.ConnectionId
	}
	return ""
}

func (m *MsgRegisterInterchainQuery) GetUpdatePeriod() uint64 {
	if m != nil {
		return m.UpdatePeriod
	}
	return 0
}

func (m *MsgRegisterInterchainQuery) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// Response type for the Msg/RegisterInterchainQuery RPC method.
type MsgRegisterInterchainQueryResponse struct {
	// The ID assigned to the registered Interchain Query by the module.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MsgRegisterInterchainQueryResponse) Reset()         { *m = MsgRegisterInterchainQueryResponse{} }
func (m *MsgRegisterInterchainQueryResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterInterchainQueryResponse) ProtoMessage()    {}
func (*MsgRegisterInterchainQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{1}
}
func (m *MsgRegisterInterchainQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterInterchainQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterInterchainQueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterInterchainQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterInterchainQueryResponse.Merge(m, src)
}
func (m *MsgRegisterInterchainQueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterInterchainQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterInterchainQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterInterchainQueryResponse proto.InternalMessageInfo

func (m *MsgRegisterInterchainQueryResponse) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// Request type for the Msg/SubmitQueryResult RPC method.
type MsgSubmitQueryResult struct {
	// The ID of the Interchain Query.
	QueryId uint64 `protobuf:"varint,1,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
	// The signer of the message.
	Sender string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	// The IBC client ID that corresponds to the IBC connection to the remote chain (where the
	// query result is coming from).
	// Deprecated: populating this field does not make any affect
	ClientId string `protobuf:"bytes,3,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"` // Deprecated: Do not use.
	// The result of the Interchain Query execution.
	Result *QueryResult `protobuf:"bytes,4,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *MsgSubmitQueryResult) Reset()         { *m = MsgSubmitQueryResult{} }
func (m *MsgSubmitQueryResult) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitQueryResult) ProtoMessage()    {}
func (*MsgSubmitQueryResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{2}
}
func (m *MsgSubmitQueryResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitQueryResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitQueryResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitQueryResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitQueryResult.Merge(m, src)
}
func (m *MsgSubmitQueryResult) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitQueryResult) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitQueryResult.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitQueryResult proto.InternalMessageInfo

func (m *MsgSubmitQueryResult) GetQueryId() uint64 {
	if m != nil {
		return m.QueryId
	}
	return 0
}

func (m *MsgSubmitQueryResult) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// Deprecated: Do not use.
func (m *MsgSubmitQueryResult) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *MsgSubmitQueryResult) GetResult() *QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// Contains different information about a single Interchain Query execution result. Currently,
// this structure is used both in query result submission via an ICQ Relayer and as a query result
// storage for read/write operations to interchainqueries module, but the structure fields are
// populated in a bit different ways. When submitting a query result, all fields are populated and
// provided to the interchainqueries module in order to verify the result against the IBC client's
// state. But in order to lighten the chain state, the interchainqueries module removes the block
// field and proofs from the kv_results.
type QueryResult struct {
	// A list of a KV Interchain Query execution results. Each result contains query parameters, a
	// response value and a proof.
	KvResults []*StorageValue `protobuf:"bytes,1,rep,name=kv_results,json=kvResults,proto3" json:"kv_results,omitempty"`
	// A TX Interchain Query execution result. Contains metainformation about the blocks of the query
	// execution height. Only populated when submitting an Interchain Query result for verification
	// and emptied when saving the result on chain.
	Block *Block `protobuf:"bytes,2,opt,name=block,proto3" json:"block,omitempty"`
	// The height of the chain at the moment of the Interchain Query execution.
	Height uint64 `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	// The revision number of the chain at the moment of the Interchain Query execution.
	Revision uint64 `protobuf:"varint,4,opt,name=revision,proto3" json:"revision,omitempty"`
	// Whether to send the query result to the owner contract as a sudo message. Only applicable for
	// KV type of Interchain Queries.
	AllowKvCallbacks bool `protobuf:"varint,5,opt,name=allow_kv_callbacks,json=allowKvCallbacks,proto3" json:"allow_kv_callbacks,omitempty"`
}

func (m *QueryResult) Reset()         { *m = QueryResult{} }
func (m *QueryResult) String() string { return proto.CompactTextString(m) }
func (*QueryResult) ProtoMessage()    {}
func (*QueryResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{3}
}
func (m *QueryResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResult.Merge(m, src)
}
func (m *QueryResult) XXX_Size() int {
	return m.Size()
}
func (m *QueryResult) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResult.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResult proto.InternalMessageInfo

func (m *QueryResult) GetKvResults() []*StorageValue {
	if m != nil {
		return m.KvResults
	}
	return nil
}

func (m *QueryResult) GetBlock() *Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *QueryResult) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *QueryResult) GetRevision() uint64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *QueryResult) GetAllowKvCallbacks() bool {
	if m != nil {
		return m.AllowKvCallbacks
	}
	return false
}

// A verifiable result of performing a single KVKey read.
type StorageValue struct {
	// The substore name used in the read operation. Typically, this corresponds to the keeper's
	// storeKey, usually the module's name, such as "bank", "staking", etc.
	StoragePrefix string `protobuf:"bytes,1,opt,name=storage_prefix,json=storagePrefix,proto3" json:"storage_prefix,omitempty"`
	// A bytes field representing the key of the data read from the module's storage.
	Key []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// A bytes field containing the value associated with the key in the store.
	Value []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// The Merkle Proof which proves existence/nonexistence of key-value pair in IAVL storage. Is
	// used to verify
	// the pair against the respective remote chain's header.
	Proof *crypto.ProofOps `protobuf:"bytes,4,opt,name=Proof,proto3" json:"Proof,omitempty"`
}

func (m *StorageValue) Reset()         { *m = StorageValue{} }
func (m *StorageValue) String() string { return proto.CompactTextString(m) }
func (*StorageValue) ProtoMessage()    {}
func (*StorageValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{4}
}
func (m *StorageValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageValue.Merge(m, src)
}
func (m *StorageValue) XXX_Size() int {
	return m.Size()
}
func (m *StorageValue) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageValue.DiscardUnknown(m)
}

var xxx_messageInfo_StorageValue proto.InternalMessageInfo

func (m *StorageValue) GetStoragePrefix() string {
	if m != nil {
		return m.StoragePrefix
	}
	return ""
}

func (m *StorageValue) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *StorageValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *StorageValue) GetProof() *crypto.ProofOps {
	if m != nil {
		return m.Proof
	}
	return nil
}

// A single verifiable result of an Interchain Query of TX type.
type Block struct {
	// The header of the block next to the block the transaction is included in. It is needed to know
	// block X+1 header to verify response of transaction for block X since LastResultsHash is root
	// hash of all results of the txs from the previous block.
	NextBlockHeader *types.Any `protobuf:"bytes,1,opt,name=next_block_header,json=nextBlockHeader,proto3" json:"next_block_header,omitempty"`
	// The header of the block the transaction is included in. It is needed to know block header to
	// verify inclusion of the transaction.
	Header *types.Any `protobuf:"bytes,2,opt,name=header,proto3" json:"header,omitempty"`
	// The transaction matched by the Interchain Query's transaction filter.
	Tx *TxValue `protobuf:"bytes,3,opt,name=tx,proto3" json:"tx,omitempty"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{5}
}
func (m *Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(m, src)
}
func (m *Block) XXX_Size() int {
	return m.Size()
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

func (m *Block) GetNextBlockHeader() *types.Any {
	if m != nil {
		return m.NextBlockHeader
	}
	return nil
}

func (m *Block) GetHeader() *types.Any {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Block) GetTx() *TxValue {
	if m != nil {
		return m.Tx
	}
	return nil
}

// Contains transaction body, response, and proofs of inclusion and delivery.
type TxValue struct {
	// The result of the transaction execution.
	Response *types1.ExecTxResult `protobuf:"bytes,1,opt,name=response,proto3" json:"response,omitempty"`
	// The Merkle Proof which proves existence of response in the block next to the block the
	// transaction is included in.
	DeliveryProof *crypto.Proof `protobuf:"bytes,2,opt,name=delivery_proof,json=deliveryProof,proto3" json:"delivery_proof,omitempty"`
	// The Merkle Proof which proves inclusion of the transaction in the block.
	InclusionProof *crypto.Proof `protobuf:"bytes,3,opt,name=inclusion_proof,json=inclusionProof,proto3" json:"inclusion_proof,omitempty"`
	// The arbitrary data typed body of the transaction.
	Data []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TxValue) Reset()         { *m = TxValue{} }
func (m *TxValue) String() string { return proto.CompactTextString(m) }
func (*TxValue) ProtoMessage()    {}
func (*TxValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{6}
}
func (m *TxValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxValue.Merge(m, src)
}
func (m *TxValue) XXX_Size() int {
	return m.Size()
}
func (m *TxValue) XXX_DiscardUnknown() {
	xxx_messageInfo_TxValue.DiscardUnknown(m)
}

var xxx_messageInfo_TxValue proto.InternalMessageInfo

func (m *TxValue) GetResponse() *types1.ExecTxResult {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *TxValue) GetDeliveryProof() *crypto.Proof {
	if m != nil {
		return m.DeliveryProof
	}
	return nil
}

func (m *TxValue) GetInclusionProof() *crypto.Proof {
	if m != nil {
		return m.InclusionProof
	}
	return nil
}

func (m *TxValue) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Response type for the Msg/SubmitQueryResult RPC method.
type MsgSubmitQueryResultResponse struct {
}

func (m *MsgSubmitQueryResultResponse) Reset()         { *m = MsgSubmitQueryResultResponse{} }
func (m *MsgSubmitQueryResultResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitQueryResultResponse) ProtoMessage()    {}
func (*MsgSubmitQueryResultResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{7}
}
func (m *MsgSubmitQueryResultResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitQueryResultResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitQueryResultResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitQueryResultResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitQueryResultResponse.Merge(m, src)
}
func (m *MsgSubmitQueryResultResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitQueryResultResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitQueryResultResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitQueryResultResponse proto.InternalMessageInfo

// Request type for the Msg/RemoveInterchainQuery RPC method.
type MsgRemoveInterchainQueryRequest struct {
	// The ID of the query to remove.
	QueryId uint64 `protobuf:"varint,1,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
	// The signer of the message.
	Sender string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
}

func (m *MsgRemoveInterchainQueryRequest) Reset()         { *m = MsgRemoveInterchainQueryRequest{} }
func (m *MsgRemoveInterchainQueryRequest) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveInterchainQueryRequest) ProtoMessage()    {}
func (*MsgRemoveInterchainQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{8}
}
func (m *MsgRemoveInterchainQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveInterchainQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveInterchainQueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveInterchainQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveInterchainQueryRequest.Merge(m, src)
}
func (m *MsgRemoveInterchainQueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveInterchainQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveInterchainQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveInterchainQueryRequest proto.InternalMessageInfo

func (m *MsgRemoveInterchainQueryRequest) GetQueryId() uint64 {
	if m != nil {
		return m.QueryId
	}
	return 0
}

func (m *MsgRemoveInterchainQueryRequest) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// Response type for the Msg/RemoveInterchainQuery RPC method.
type MsgRemoveInterchainQueryResponse struct {
}

func (m *MsgRemoveInterchainQueryResponse) Reset()         { *m = MsgRemoveInterchainQueryResponse{} }
func (m *MsgRemoveInterchainQueryResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveInterchainQueryResponse) ProtoMessage()    {}
func (*MsgRemoveInterchainQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{9}
}
func (m *MsgRemoveInterchainQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveInterchainQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveInterchainQueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveInterchainQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveInterchainQueryResponse.Merge(m, src)
}
func (m *MsgRemoveInterchainQueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveInterchainQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveInterchainQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveInterchainQueryResponse proto.InternalMessageInfo

// Request type for the Msg/UpdateInterchainQuery RPC method.
type MsgUpdateInterchainQueryRequest struct {
	// The ID of the query to update.
	QueryId uint64 `protobuf:"varint,1,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
	// A new list of KV-storage keys for which to get values from the remote chain. Only applicable
	// for a KV Interchain Query. Max amount of keys is limited by the module's `max_kv_query_keys_count`
	// parameters.
	NewKeys []*KVKey `protobuf:"bytes,2,rep,name=new_keys,json=newKeys,proto3" json:"new_keys,omitempty"`
	// A new minimal delay between consecutive query executions.
	NewUpdatePeriod uint64 `protobuf:"varint,3,opt,name=new_update_period,json=newUpdatePeriod,proto3" json:"new_update_period,omitempty"`
	// A new list of filters for remote transactions search. Only applicable for a TX Interchain
	// Query. Example: "[{\"field\":\"tx.height\",\"op\":\"Gte\",\"value\":2644737}]".
	// Supported operators: "eq", "lt", "gt", "lte", "gte". Max amount of filter conditions is
	// limited by the module's `max_transactions_filters` parameters.
	NewTransactionsFilter string `protobuf:"bytes,4,opt,name=new_transactions_filter,json=newTransactionsFilter,proto3" json:"new_transactions_filter,omitempty"`
	// The signer of the message.
	Sender string `protobuf:"bytes,5,opt,name=sender,proto3" json:"sender,omitempty"`
}

func (m *MsgUpdateInterchainQueryRequest) Reset()         { *m = MsgUpdateInterchainQueryRequest{} }
func (m *MsgUpdateInterchainQueryRequest) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateInterchainQueryRequest) ProtoMessage()    {}
func (*MsgUpdateInterchainQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{10}
}
func (m *MsgUpdateInterchainQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateInterchainQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateInterchainQueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateInterchainQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateInterchainQueryRequest.Merge(m, src)
}
func (m *MsgUpdateInterchainQueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateInterchainQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateInterchainQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateInterchainQueryRequest proto.InternalMessageInfo

func (m *MsgUpdateInterchainQueryRequest) GetQueryId() uint64 {
	if m != nil {
		return m.QueryId
	}
	return 0
}

func (m *MsgUpdateInterchainQueryRequest) GetNewKeys() []*KVKey {
	if m != nil {
		return m.NewKeys
	}
	return nil
}

func (m *MsgUpdateInterchainQueryRequest) GetNewUpdatePeriod() uint64 {
	if m != nil {
		return m.NewUpdatePeriod
	}
	return 0
}

func (m *MsgUpdateInterchainQueryRequest) GetNewTransactionsFilter() string {
	if m != nil {
		return m.NewTransactionsFilter
	}
	return ""
}

func (m *MsgUpdateInterchainQueryRequest) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

// Response type for the Msg/UpdateInterchainQuery RPC method.
type MsgUpdateInterchainQueryResponse struct {
}

func (m *MsgUpdateInterchainQueryResponse) Reset()         { *m = MsgUpdateInterchainQueryResponse{} }
func (m *MsgUpdateInterchainQueryResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateInterchainQueryResponse) ProtoMessage()    {}
func (*MsgUpdateInterchainQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{11}
}
func (m *MsgUpdateInterchainQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateInterchainQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateInterchainQueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateInterchainQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateInterchainQueryResponse.Merge(m, src)
}
func (m *MsgUpdateInterchainQueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateInterchainQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateInterchainQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateInterchainQueryResponse proto.InternalMessageInfo

// Request type for the Msg/UpdateParams RPC method.
type MsgUpdateParams struct {
	// The address of the authority of the module.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// The new parameters of the module. All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{12}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// Response type for the Msg/UpdateParams RPC method.
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d4793837a316491e, []int{13}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgRegisterInterchainQuery)(nil), "neutron.interchainqueries.MsgRegisterInterchainQuery")
	proto.RegisterType((*MsgRegisterInterchainQueryResponse)(nil), "neutron.interchainqueries.MsgRegisterInterchainQueryResponse")
	proto.RegisterType((*MsgSubmitQueryResult)(nil), "neutron.interchainqueries.MsgSubmitQueryResult")
	proto.RegisterType((*QueryResult)(nil), "neutron.interchainqueries.QueryResult")
	proto.RegisterType((*StorageValue)(nil), "neutron.interchainqueries.StorageValue")
	proto.RegisterType((*Block)(nil), "neutron.interchainqueries.Block")
	proto.RegisterType((*TxValue)(nil), "neutron.interchainqueries.TxValue")
	proto.RegisterType((*MsgSubmitQueryResultResponse)(nil), "neutron.interchainqueries.MsgSubmitQueryResultResponse")
	proto.RegisterType((*MsgRemoveInterchainQueryRequest)(nil), "neutron.interchainqueries.MsgRemoveInterchainQueryRequest")
	proto.RegisterType((*MsgRemoveInterchainQueryResponse)(nil), "neutron.interchainqueries.MsgRemoveInterchainQueryResponse")
	proto.RegisterType((*MsgUpdateInterchainQueryRequest)(nil), "neutron.interchainqueries.MsgUpdateInterchainQueryRequest")
	proto.RegisterType((*MsgUpdateInterchainQueryResponse)(nil), "neutron.interchainqueries.MsgUpdateInterchainQueryResponse")
	proto.RegisterType((*MsgUpdateParams)(nil), "neutron.interchainqueries.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "neutron.interchainqueries.MsgUpdateParamsResponse")
}

func init() {
	proto.RegisterFile("neutron/interchainqueries/tx.proto", fileDescriptor_d4793837a316491e)
}

var fileDescriptor_d4793837a316491e = []byte{
	// 1168 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcd, 0x4f, 0x1b, 0x47,
	0x14, 0x67, 0x8d, 0x4d, 0xf0, 0xe0, 0x40, 0x32, 0x25, 0xc5, 0x38, 0x8d, 0x43, 0xb6, 0x6a, 0x12,
	0xa1, 0x64, 0x57, 0x71, 0x29, 0x55, 0x41, 0xfd, 0x80, 0xb6, 0x51, 0x11, 0x42, 0xa5, 0x0b, 0xe4,
	0xd0, 0xcb, 0x6a, 0xbd, 0x3b, 0xac, 0x47, 0x5e, 0xcf, 0x38, 0x3b, 0xb3, 0xfe, 0x38, 0x54, 0xaa,
	0x72, 0xec, 0xa5, 0xf4, 0xbf, 0xa8, 0xd4, 0x0b, 0x52, 0x2b, 0xf5, 0x2f, 0xa8, 0x94, 0x63, 0xd4,
	0x53, 0x0f, 0x55, 0x55, 0xc1, 0x81, 0x63, 0xff, 0x85, 0x6a, 0x3e, 0xd6, 0x98, 0x18, 0x9b, 0xc0,
	0x05, 0xf6, 0xbd, 0xf7, 0x7b, 0x6f, 0x7e, 0xf3, 0xe6, 0x7d, 0x18, 0x98, 0x04, 0x25, 0x3c, 0xa6,
	0xc4, 0xc6, 0x84, 0xa3, 0xd8, 0xaf, 0x79, 0x98, 0x3c, 0x4f, 0x50, 0x8c, 0x11, 0xb3, 0x79, 0xc7,
	0x6a, 0xc6, 0x94, 0x53, 0x38, 0xaf, 0x31, 0xd6, 0x00, 0xa6, 0x74, 0xd3, 0x6b, 0x60, 0x42, 0x6d,
	0xf9, 0x57, 0xa1, 0x4b, 0x73, 0x3e, 0x65, 0x0d, 0xca, 0xec, 0x06, 0x0b, 0xed, 0xd6, 0x13, 0xf1,
	0x4f, 0x1b, 0xe6, 0x95, 0xc1, 0x95, 0x92, 0xad, 0x04, 0x6d, 0x9a, 0x0d, 0x69, 0x48, 0x95, 0x5e,
	0x7c, 0xa5, 0x0e, 0x21, 0xa5, 0x61, 0x84, 0x6c, 0x29, 0x55, 0x93, 0x7d, 0xdb, 0x23, 0x5d, 0x6d,
	0x7a, 0x30, 0x9c, 0x76, 0x88, 0x08, 0x62, 0x38, 0x8d, 0x7c, 0x7f, 0x38, 0xb0, 0xe9, 0xc5, 0x5e,
	0x23, 0xc5, 0xdd, 0xe6, 0x88, 0x04, 0x28, 0x6e, 0x60, 0xc2, 0x6d, 0xaf, 0xea, 0x63, 0x9b, 0x77,
	0x9b, 0x28, 0x35, 0xde, 0xe9, 0x33, 0xfa, 0x71, 0xb7, 0xc9, 0xa9, 0xe0, 0x44, 0xf7, 0x95, 0xd9,
	0xfc, 0x29, 0x03, 0x4a, 0x5b, 0x2c, 0x74, 0x50, 0x88, 0x19, 0x47, 0xf1, 0x46, 0xef, 0xa4, 0x6f,
	0x12, 0x14, 0x77, 0xe1, 0x1d, 0x00, 0xc4, 0x91, 0x5d, 0x57, 0x84, 0x2c, 0x1a, 0x0b, 0xc6, 0xc3,
	0xbc, 0x93, 0x97, 0x9a, 0xdd, 0x6e, 0x13, 0xc1, 0x25, 0x90, 0xad, 0xa3, 0x2e, 0x2b, 0x66, 0x16,
	0xc6, 0x1f, 0x4e, 0x55, 0x16, 0xac, 0xa1, 0xc9, 0xb6, 0x36, 0x9f, 0x6d, 0xa2, 0xae, 0x23, 0xd1,
	0xd0, 0x06, 0x6f, 0xf1, 0xd8, 0x23, 0xcc, 0xf3, 0x39, 0xa6, 0x84, 0xb9, 0xfb, 0x38, 0xe2, 0x28,
	0x2e, 0x8e, 0xcb, 0xe8, 0xb0, 0xdf, 0xf4, 0x54, 0x5a, 0xe0, 0xbb, 0xe0, 0xba, 0x4f, 0x09, 0x41,
	0x52, 0xe9, 0xe2, 0xa0, 0x98, 0x95, 0xd0, 0xc2, 0xa9, 0x72, 0x23, 0x10, 0xa0, 0xa4, 0x19, 0x78,
	0x1c, 0xb9, 0x4d, 0x14, 0x63, 0x1a, 0x14, 0x73, 0x0b, 0xc6, 0xc3, 0xac, 0x53, 0x50, 0xca, 0x6d,
	0xa9, 0x83, 0x6f, 0x83, 0x09, 0x26, 0xf3, 0x51, 0x9c, 0x90, 0x21, 0xb4, 0xb4, 0x32, 0xf5, 0xe2,
	0xe4, 0x70, 0x51, 0x0b, 0xe6, 0x12, 0x30, 0x87, 0xa7, 0xc4, 0x41, 0xac, 0x49, 0x09, 0x43, 0x70,
	0x1a, 0x64, 0x70, 0x20, 0x53, 0x92, 0x75, 0x32, 0x38, 0x30, 0x7f, 0x37, 0xc0, 0xec, 0x16, 0x0b,
	0x77, 0x92, 0x6a, 0x03, 0xf3, 0x14, 0x9a, 0x44, 0x1c, 0xce, 0x83, 0x49, 0x95, 0xc3, 0x1e, 0xfc,
	0x9a, 0x94, 0x37, 0xfa, 0xe9, 0x64, 0xfa, 0xe9, 0xc0, 0xbb, 0x20, 0xef, 0x47, 0x18, 0x11, 0x2e,
	0x7c, 0x64, 0x5e, 0xd6, 0x33, 0x45, 0xc3, 0x99, 0x54, 0xca, 0x8d, 0x00, 0x7e, 0x02, 0x26, 0x62,
	0x19, 0x5d, 0xa6, 0x62, 0xaa, 0x72, 0x7f, 0x44, 0xea, 0xfb, 0xb8, 0x38, 0xda, 0xeb, 0xec, 0x7d,
	0xff, 0x33, 0xc0, 0x54, 0x3f, 0xe1, 0xa7, 0x00, 0xd4, 0x5b, 0xae, 0x42, 0xb2, 0xa2, 0x21, 0xdf,
	0xf6, 0xc1, 0x88, 0x03, 0x76, 0x38, 0x8d, 0xbd, 0x10, 0x3d, 0xf3, 0xa2, 0x04, 0x39, 0xf9, 0x7a,
	0x4b, 0x85, 0x61, 0x70, 0x19, 0xe4, 0xaa, 0x11, 0xf5, 0xeb, 0xf2, 0x72, 0xa3, 0xcb, 0x63, 0x5d,
	0xe0, 0x1c, 0x05, 0x17, 0x59, 0xa9, 0x21, 0x1c, 0xd6, 0xb8, 0xbc, 0x7a, 0xd6, 0xd1, 0x12, 0x2c,
	0x81, 0xc9, 0x18, 0xb5, 0x30, 0xc3, 0x94, 0xc8, 0x6b, 0x67, 0x9d, 0x9e, 0x0c, 0x1f, 0x01, 0xe8,
	0x45, 0x11, 0x6d, 0xbb, 0xf5, 0x96, 0xeb, 0x7b, 0x51, 0x54, 0xf5, 0xfc, 0x3a, 0x93, 0x25, 0x30,
	0xe9, 0xdc, 0x90, 0x96, 0xcd, 0xd6, 0xe7, 0xa9, 0xde, 0x3c, 0x30, 0x40, 0xa1, 0x9f, 0x35, 0x7c,
	0x0f, 0x4c, 0x33, 0x25, 0xbb, 0xcd, 0x18, 0xed, 0xe3, 0x8e, 0xae, 0xf5, 0xeb, 0x5a, 0xbb, 0x2d,
	0x95, 0xf0, 0x06, 0x18, 0xaf, 0xa3, 0xae, 0xbc, 0x4f, 0xc1, 0x11, 0x9f, 0x70, 0x16, 0xe4, 0x5a,
	0x22, 0x82, 0xa4, 0x5a, 0x70, 0x94, 0x00, 0x9f, 0x80, 0xdc, 0xb6, 0x68, 0x32, 0xfd, 0x3a, 0xb7,
	0xad, 0xd3, 0x26, 0xb4, 0x54, 0x13, 0x5a, 0xd2, 0xfe, 0x75, 0x93, 0x39, 0x0a, 0x69, 0xfe, 0x62,
	0x80, 0x9c, 0xcc, 0x02, 0xfc, 0x0c, 0xdc, 0x24, 0xa8, 0xc3, 0x5d, 0x99, 0x0c, 0xb7, 0x86, 0x3c,
	0x51, 0x1f, 0x86, 0x0c, 0x34, 0x6b, 0xa9, 0xb1, 0x62, 0xa5, 0x63, 0xc5, 0x5a, 0x23, 0x5d, 0x67,
	0x46, 0xc0, 0xa5, 0xef, 0x57, 0x12, 0x0c, 0x1f, 0x89, 0x04, 0x7a, 0x69, 0x59, 0x0d, 0x73, 0xd3,
	0x18, 0x58, 0x01, 0x19, 0xde, 0x91, 0xfc, 0xa7, 0x2a, 0xe6, 0x88, 0x37, 0xda, 0xed, 0xa8, 0x17,
	0xce, 0xf0, 0x8e, 0xf9, 0xb7, 0x01, 0xae, 0x69, 0x19, 0x7e, 0x24, 0x9e, 0x45, 0x35, 0x85, 0xa6,
	0x79, 0xa7, 0xff, 0xbe, 0x62, 0x22, 0x59, 0x5f, 0x76, 0x90, 0xbf, 0xdb, 0xd1, 0x45, 0xd8, 0x83,
	0xc3, 0x4f, 0xc1, 0x74, 0x80, 0x22, 0xdc, 0x12, 0xdd, 0x21, 0xa7, 0x92, 0x26, 0x5c, 0x1c, 0x96,
	0x30, 0xe7, 0x7a, 0x8a, 0x97, 0x22, 0x5c, 0x03, 0x33, 0x98, 0xf8, 0x51, 0x22, 0x6a, 0x40, 0x47,
	0x18, 0xbf, 0x20, 0xc2, 0x74, 0xcf, 0x41, 0x85, 0x80, 0x20, 0x1b, 0x78, 0xdc, 0x93, 0x4f, 0x55,
	0x70, 0xe4, 0xb7, 0x59, 0x06, 0xef, 0x9c, 0xd7, 0xca, 0x69, 0xef, 0x9b, 0x1e, 0xb8, 0x2b, 0x27,
	0x44, 0x83, 0xb6, 0xd0, 0xc0, 0x7c, 0x78, 0x9e, 0x20, 0x76, 0x95, 0xae, 0x3f, 0xdb, 0x94, 0x26,
	0x58, 0x18, 0x7e, 0x84, 0xa6, 0xf1, 0x22, 0x23, 0x79, 0xec, 0xc9, 0x09, 0x77, 0x79, 0x1e, 0xab,
	0x60, 0x92, 0xa0, 0xb6, 0x7b, 0xa9, 0x09, 0x7e, 0x8d, 0xa0, 0xf6, 0xa6, 0x18, 0xe2, 0x8b, 0xa2,
	0x4a, 0xdb, 0xee, 0xd9, 0x91, 0xab, 0xfa, 0x75, 0x86, 0xa0, 0xf6, 0x5e, 0xff, 0xd4, 0x5d, 0x06,
	0x73, 0x02, 0x7b, 0xde, 0xd0, 0x57, 0x93, 0xfc, 0x16, 0x41, 0xed, 0xdd, 0xc1, 0xb9, 0x7f, 0x9a,
	0xa8, 0xdc, 0x45, 0x89, 0x1a, 0x92, 0x03, 0x9d, 0xa8, 0x3f, 0x0c, 0x30, 0xd3, 0x03, 0x6d, 0xcb,
	0xdd, 0x09, 0x97, 0x41, 0xde, 0x4b, 0x78, 0x8d, 0xc6, 0x98, 0x77, 0x55, 0xb7, 0xaf, 0x17, 0xff,
	0xfc, 0xed, 0xf1, 0xac, 0x5e, 0xee, 0x6b, 0x41, 0x10, 0x23, 0xc6, 0x76, 0x78, 0x8c, 0x49, 0xe8,
	0x9c, 0x42, 0xe1, 0x17, 0x60, 0x42, 0x6d, 0x5f, 0x5d, 0xab, 0xf7, 0x46, 0xe4, 0x4c, 0x1d, 0xb5,
	0x9e, 0x7f, 0xf9, 0xcf, 0xdd, 0xb1, 0x9f, 0x4f, 0x0e, 0x17, 0x0d, 0x47, 0xfb, 0xae, 0x2c, 0x89,
	0x2b, 0x9c, 0x46, 0xfd, 0xe1, 0xe4, 0x70, 0xf1, 0xde, 0xe0, 0x9a, 0x7f, 0x8d, 0xb3, 0x39, 0x0f,
	0xe6, 0x5e, 0x53, 0xa5, 0x57, 0xac, 0xfc, 0x9a, 0x03, 0xe3, 0x5b, 0x2c, 0x84, 0x3f, 0x1a, 0x60,
	0x6e, 0xd8, 0x36, 0xff, 0x60, 0x04, 0xd5, 0xe1, 0x1b, 0xaf, 0xf4, 0xf1, 0x95, 0xdc, 0x7a, 0x8b,
	0xf2, 0x3b, 0x70, 0x73, 0x70, 0x29, 0xda, 0xa3, 0x63, 0x0e, 0x38, 0x94, 0x3e, 0xbc, 0xa4, 0x43,
	0xef, 0xf8, 0x03, 0x03, 0xdc, 0x3a, 0xb7, 0x8d, 0xe0, 0xca, 0x45, 0xf7, 0x1a, 0xde, 0xde, 0xa5,
	0xd5, 0x2b, 0xf9, 0xf6, 0x51, 0x3a, 0xb7, 0x60, 0x2f, 0xa2, 0x34, 0xaa, 0xd3, 0x2f, 0xa2, 0x34,
	0xb2, 0x43, 0x20, 0x01, 0x85, 0x33, 0xdd, 0xb1, 0xf8, 0x26, 0xc1, 0x14, 0xb6, 0x54, 0x79, 0x73,
	0x6c, 0x7a, 0x5e, 0x29, 0xf7, 0xbd, 0x68, 0x87, 0xf5, 0xbd, 0x97, 0x47, 0x65, 0xe3, 0xd5, 0x51,
	0xd9, 0xf8, 0xf7, 0xa8, 0x6c, 0x1c, 0x1c, 0x97, 0xc7, 0x5e, 0x1d, 0x97, 0xc7, 0xfe, 0x3a, 0x2e,
	0x8f, 0x7d, 0xbb, 0x1a, 0x62, 0x5e, 0x4b, 0xaa, 0x96, 0x4f, 0x1b, 0xb6, 0x0e, 0xff, 0x98, 0xc6,
	0x61, 0xfa, 0x6d, 0xb7, 0x96, 0xed, 0xce, 0x79, 0x3f, 0xfc, 0xc5, 0x4f, 0xdf, 0xea, 0x84, 0x5c,
	0x74, 0xef, 0xff, 0x1f, 0x00, 0x00, 0xff, 0xff, 0xb6, 0x91, 0x31, 0xf5, 0x22, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Registers a new Interchain Query in the `interchainqueries` module. This message should only
	// be issued by a smart contract. The calling contract is automatically charged a query
	// registration deposit, based on the module's query deposit parameter. The deposit is refunded
	// when the query is removed. Ensure the contract's account has sufficient assets at the time of
	// message execution.
	//
	// The response includes the ID assigned to the registered query. Use a reply handler to process
	// this response and utilize the query ID.
	RegisterInterchainQuery(ctx context.Context, in *MsgRegisterInterchainQuery, opts ...grpc.CallOption) (*MsgRegisterInterchainQueryResponse, error)
	// Submits the result of an Interchain Query execution to the chain. Handling this message may
	// involve forwarding the result to the smart contract that owns the query for processing, which
	// could require significant gas usage.
	SubmitQueryResult(ctx context.Context, in *MsgSubmitQueryResult, opts ...grpc.CallOption) (*MsgSubmitQueryResultResponse, error)
	// Removes a specific Interchain Query and its results from the module. The query can only be
	// removed by its owner during the query's submit timeout. After the timeout, anyone can remove
	// it. Upon successful removal, the query deposit is refunded to the caller.
	RemoveInterchainQuery(ctx context.Context, in *MsgRemoveInterchainQueryRequest, opts ...grpc.CallOption) (*MsgRemoveInterchainQueryResponse, error)
	// Updates the parameters of a registered Interchain Query. This action can only be performed by
	// the query's owner.
	UpdateInterchainQuery(ctx context.Context, in *MsgUpdateInterchainQueryRequest, opts ...grpc.CallOption) (*MsgUpdateInterchainQueryResponse, error)
	// Updates the parameters of the `interchainqueries` module. This action can only be performed
	// by the module's authority.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) RegisterInterchainQuery(ctx context.Context, in *MsgRegisterInterchainQuery, opts ...grpc.CallOption) (*MsgRegisterInterchainQueryResponse, error) {
	out := new(MsgRegisterInterchainQueryResponse)
	err := c.cc.Invoke(ctx, "/neutron.interchainqueries.Msg/RegisterInterchainQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitQueryResult(ctx context.Context, in *MsgSubmitQueryResult, opts ...grpc.CallOption) (*MsgSubmitQueryResultResponse, error) {
	out := new(MsgSubmitQueryResultResponse)
	err := c.cc.Invoke(ctx, "/neutron.interchainqueries.Msg/SubmitQueryResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoveInterchainQuery(ctx context.Context, in *MsgRemoveInterchainQueryRequest, opts ...grpc.CallOption) (*MsgRemoveInterchainQueryResponse, error) {
	out := new(MsgRemoveInterchainQueryResponse)
	err := c.cc.Invoke(ctx, "/neutron.interchainqueries.Msg/RemoveInterchainQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateInterchainQuery(ctx context.Context, in *MsgUpdateInterchainQueryRequest, opts ...grpc.CallOption) (*MsgUpdateInterchainQueryResponse, error) {
	out := new(MsgUpdateInterchainQueryResponse)
	err := c.cc.Invoke(ctx, "/neutron.interchainqueries.Msg/UpdateInterchainQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/neutron.interchainqueries.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Registers a new Interchain Query in the `interchainqueries` module. This message should only
	// be issued by a smart contract. The calling contract is automatically charged a query
	// registration deposit, based on the module's query deposit parameter. The deposit is refunded
	// when the query is removed. Ensure the contract's account has sufficient assets at the time of
	// message execution.
	//
	// The response includes the ID assigned to the registered query. Use a reply handler to process
	// this response and utilize the query ID.
	RegisterInterchainQuery(context.Context, *MsgRegisterInterchainQuery) (*MsgRegisterInterchainQueryResponse, error)
	// Submits the result of an Interchain Query execution to the chain. Handling this message may
	// involve forwarding the result to the smart contract that owns the query for processing, which
	// could require significant gas usage.
	SubmitQueryResult(context.Context, *MsgSubmitQueryResult) (*MsgSubmitQueryResultResponse, error)
	// Removes a specific Interchain Query and its results from the module. The query can only be
	// removed by its owner during the query's submit timeout. After the timeout, anyone can remove
	// it. Upon successful removal, the query deposit is refunded to the caller.
	RemoveInterchainQuery(context.Context, *MsgRemoveInterchainQueryRequest) (*MsgRemoveInterchainQueryResponse, error)
	// Updates the parameters of a registered Interchain Query. This action can only be performed by
	// the query's owner.
	UpdateInterchainQuery(context.Context, *MsgUpdateInterchainQueryRequest) (*MsgUpdateInterchainQueryResponse, error)
	// Updates the parameters of the `interchainqueries` module. This action can only be performed
	// by the module's authority.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) RegisterInterchainQuery(ctx context.Context, req *MsgRegisterInterchainQuery) (*MsgRegisterInterchainQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterInterchainQuery not implemented")
}
func (*UnimplementedMsgServer) SubmitQueryResult(ctx context.Context, req *MsgSubmitQueryResult) (*MsgSubmitQueryResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitQueryResult not implemented")
}
func (*UnimplementedMsgServer) RemoveInterchainQuery(ctx context.Context, req *MsgRemoveInterchainQueryRequest) (*MsgRemoveInterchainQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveInterchainQuery not implemented")
}
func (*UnimplementedMsgServer) UpdateInterchainQuery(ctx context.Context, req *MsgUpdateInterchainQueryRequest) (*MsgUpdateInterchainQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInterchainQuery not implemented")
}
func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_RegisterInterchainQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterInterchainQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterInterchainQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutron.interchainqueries.Msg/RegisterInterchainQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterInterchainQuery(ctx, req.(*MsgRegisterInterchainQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitQueryResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitQueryResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitQueryResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutron.interchainqueries.Msg/SubmitQueryResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitQueryResult(ctx, req.(*MsgSubmitQueryResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoveInterchainQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoveInterchainQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoveInterchainQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutron.interchainqueries.Msg/RemoveInterchainQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoveInterchainQuery(ctx, req.(*MsgRemoveInterchainQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateInterchainQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateInterchainQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateInterchainQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutron.interchainqueries.Msg/UpdateInterchainQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateInterchainQuery(ctx, req.(*MsgUpdateInterchainQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/neutron.interchainqueries.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "neutron.interchainqueries.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterInterchainQuery",
			Handler:    _Msg_RegisterInterchainQuery_Handler,
		},
		{
			MethodName: "SubmitQueryResult",
			Handler:    _Msg_SubmitQueryResult_Handler,
		},
		{
			MethodName: "RemoveInterchainQuery",
			Handler:    _Msg_RemoveInterchainQuery_Handler,
		},
		{
			MethodName: "UpdateInterchainQuery",
			Handler:    _Msg_UpdateInterchainQuery_Handler,
		},
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "neutron/interchainqueries/tx.proto",
}

func (m *MsgRegisterInterchainQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterInterchainQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterInterchainQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x32
	}
	if m.UpdatePeriod != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.UpdatePeriod))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ConnectionId) > 0 {
		i -= len(m.ConnectionId)
		copy(dAtA[i:], m.ConnectionId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ConnectionId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TransactionsFilter) > 0 {
		i -= len(m.TransactionsFilter)
		copy(dAtA[i:], m.TransactionsFilter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TransactionsFilter)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Keys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.QueryType) > 0 {
		i -= len(m.QueryType)
		copy(dAtA[i:], m.QueryType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.QueryType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterInterchainQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterInterchainQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterInterchainQueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitQueryResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitQueryResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitQueryResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if m.QueryId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.QueryId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowKvCallbacks {
		i--
		if m.AllowKvCallbacks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Revision != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x20
	}
	if m.Height != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.KvResults) > 0 {
		for iNdEx := len(m.KvResults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KvResults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StorageValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StoragePrefix) > 0 {
		i -= len(m.StoragePrefix)
		copy(dAtA[i:], m.StoragePrefix)
		i = encodeVarintTx(dAtA, i, uint64(len(m.StoragePrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tx != nil {
		{
			size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NextBlockHeader != nil {
		{
			size, err := m.NextBlockHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if m.InclusionProof != nil {
		{
			size, err := m.InclusionProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DeliveryProof != nil {
		{
			size, err := m.DeliveryProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitQueryResultResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitQueryResultResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitQueryResultResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRemoveInterchainQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveInterchainQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveInterchainQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if m.QueryId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.QueryId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoveInterchainQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveInterchainQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveInterchainQueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateInterchainQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateInterchainQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateInterchainQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NewTransactionsFilter) > 0 {
		i -= len(m.NewTransactionsFilter)
		copy(dAtA[i:], m.NewTransactionsFilter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewTransactionsFilter)))
		i--
		dAtA[i] = 0x22
	}
	if m.NewUpdatePeriod != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.NewUpdatePeriod))
		i--
		dAtA[i] = 0x18
	}
	if len(m.NewKeys) > 0 {
		for iNdEx := len(m.NewKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.QueryId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.QueryId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateInterchainQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateInterchainQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateInterchainQueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgRegisterInterchainQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.QueryType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.TransactionsFilter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ConnectionId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdatePeriod != 0 {
		n += 1 + sovTx(uint64(m.UpdatePeriod))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRegisterInterchainQueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTx(uint64(m.Id))
	}
	return n
}

func (m *MsgSubmitQueryResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryId != 0 {
		n += 1 + sovTx(uint64(m.QueryId))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *QueryResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.KvResults) > 0 {
		for _, e := range m.KvResults {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTx(uint64(m.Height))
	}
	if m.Revision != 0 {
		n += 1 + sovTx(uint64(m.Revision))
	}
	if m.AllowKvCallbacks {
		n += 2
	}
	return n
}

func (m *StorageValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StoragePrefix)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NextBlockHeader != nil {
		l = m.NextBlockHeader.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *TxValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DeliveryProof != nil {
		l = m.DeliveryProof.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.InclusionProof != nil {
		l = m.InclusionProof.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitQueryResultResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRemoveInterchainQueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryId != 0 {
		n += 1 + sovTx(uint64(m.QueryId))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRemoveInterchainQueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateInterchainQueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryId != 0 {
		n += 1 + sovTx(uint64(m.QueryId))
	}
	if len(m.NewKeys) > 0 {
		for _, e := range m.NewKeys {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.NewUpdatePeriod != 0 {
		n += 1 + sovTx(uint64(m.NewUpdatePeriod))
	}
	l = len(m.NewTransactionsFilter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateInterchainQueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgRegisterInterchainQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterInterchainQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterInterchainQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &KVKey{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionsFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionsFilter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePeriod", wireType)
			}
			m.UpdatePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatePeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterInterchainQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterInterchainQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterInterchainQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitQueryResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitQueryResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitQueryResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
			}
			m.QueryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &QueryResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KvResults = append(m.KvResults, &StorageValue{})
			if err := m.KvResults[len(m.KvResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowKvCallbacks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowKvCallbacks = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoragePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoragePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &crypto.ProofOps{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextBlockHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextBlockHeader == nil {
				m.NextBlockHeader = &types.Any{}
			}
			if err := m.NextBlockHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &types.Any{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tx == nil {
				m.Tx = &TxValue{}
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &types1.ExecTxResult{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeliveryProof == nil {
				m.DeliveryProof = &crypto.Proof{}
			}
			if err := m.DeliveryProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InclusionProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InclusionProof == nil {
				m.InclusionProof = &crypto.Proof{}
			}
			if err := m.InclusionProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitQueryResultResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitQueryResultResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitQueryResultResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveInterchainQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveInterchainQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveInterchainQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
			}
			m.QueryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveInterchainQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveInterchainQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveInterchainQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateInterchainQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateInterchainQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateInterchainQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
			}
			m.QueryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewKeys = append(m.NewKeys, &KVKey{})
			if err := m.NewKeys[len(m.NewKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewUpdatePeriod", wireType)
			}
			m.NewUpdatePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewUpdatePeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTransactionsFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewTransactionsFilter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateInterchainQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateInterchainQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateInterchainQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
